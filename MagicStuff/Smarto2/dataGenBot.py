
import libpyAI as ai
class BotData:
    def __init__(self,  filename):
        self.fileHandle = open(filename,  'w')
        
        self.turnDR = DataRecorder()
        self.thrustDR = DataRecorder()
        self.shootDR = DataRecorder()
        
        #TurnThrustShoot - that is the order
        self.inputDR = DataRecorder()
        self.outputDR = DataRecorder()
        self.lines = []
        self.turnedLeft,  self.turnedRight,  self.thrusted,  self.shot = 0, 0, 0, 0
    def writeDeath():
        self.fileHandle.write("DEAD")
    def length(self):
        return len(self.lines)
    def addInput(self,  data):
        self.turnDR.add(data)
        self.thrustDR.add(data)
        self.shootDR.add(data)
    def addTurnInput(self,  data):
        self.turnDR.add(data)
    def addThrustInput(self,  data):
        self.thrustDR.add(data)
    def addShootInput(self,  data):
        self.shootDR.add(data)
    def updateInputs(self):
        
        #The code in config is inserted into the updateInputs function so you can pull any data you want using ai.(some xpilot-ai function) and adding it with self.addInput("Some Float")
        #You can technically also add outputs with self.addOutput if you want your neural network to predict or control something beyond normal but this might not work nicely with the autogenerated controller
        #The trainer checks the size of both the input and output datasets and will build a network to accomodate these sizes automatically

        #Until the next comment is code for pulling relevant data from the game
        heading = int(ai.selfHeadingDeg())
        tracking = int(ai.selfTrackingDeg())
        
        backWall = ai.wallFeeler(500, heading - 180)
        backLeftWall = ai.wallFeeler(500,  heading - 190)
        backRightWall = ai.wallFeeler(500,  heading - 170)
        
        frontWall = ai.wallFeeler(500,heading)
        flWall = ai.wallFeeler(500,  heading + 10)
        frWall = ai.wallFeeler(500,  heading - 10)
        
        leftWall = ai.wallFeeler(500,heading+90)
        llWall = ai.wallFeeler(500,  heading + 100)
        rlWall = ai.wallFeeler(500,  heading + 80)
        
        rightWall = ai.wallFeeler(500,heading-90)
        lrWall = ai.wallFeeler(500,  heading - 80)
        rrWall = ai.wallFeeler(500,  heading - 100)
        
        calcDir = -1
        targetX,  targetY = ai.screenEnemyX(0), ai.screenEnemyY(0)
        if targetX- ai.selfX() != 0:
            calcDir = (math.degrees(math.atan2((targetY - ai.selfY()), (targetX- ai.selfX()))) + 360)%360
    
        speed = ai.selfSpeed()
        fFan = min(frontWall,  flWall,  frWall)
        lFan = min(leftWall,  llWall,  rlWall)
        rFan = min(rightWall,  rrWall,  lrWall)
        bFan = min(backWall,  backLeftWall,  backRightWall)
        trackWall = ai.wallFeeler(500, tracking)
        
        #Everything below here is just selecting inputs for training - play around by commenting and uncommenting different inputs, or try adding your own!
        self.addTurnInput(frontWall/500)
        self.addTurnInput(leftWall/500)
        self.addTurnInput(rightWall/500)
        self.addTurnInput(backWall/500)
        self.addTurnInput(trackWall/500)
        #self.addTurnInput(backLeftWall/500)
        #self.addTurnInput(backRightWall/500)


        #self.addInput(fFan)
        #self.addInput(rFan)
        #self.addInput(lFan)
        #self.addInput(bFan)
        #self.addInput(tracking)

        self.addShootInput(heading/360)
        self.addShootInput(calcDir/360)
        
        self.addThrustInput(heading/360) 
        self.addThrustInput(speed/5)
        self.addThrustInput(trackWall/500)
        self.addThrustInput(backWall/500)
        self.addThrustInput(tracking/500)
        


        
    def addOutput(self,  data):
        self.outputDR.add(data)
    def updateOutputs(self):
        self.addOutput(self.turnedLeft)
        self.addOutput(self.turnedRight)
        self.addOutput(self.thrusted)
        self.addOutput(self.shot)
        self.shot = 0
        
    def reset(self):
        self.inputDR.reset()
        self.outputDR.reset()
        
    def resetInput(self):
        self.inputDR.reset()
    def savePair(self):
        self.inputDR.add(self.turnDR.getString())
        self.inputDR.add(self.thrustDR.getString())
        self.inputDR.add(self.shootDR.getString())
        
        self.lines.append(self.inputDR.getString())
        self.lines.append(self.outputDR.getString())
        
        self.turnDR.reset()
        self.thrustDR.reset()
        self.shootDR.reset()
        self.inputDR.reset()
        self.outputDR.reset()
        self.outputDR.reset()
    def deleteData(self,  pairs):
        self.lines = self.lines[0:-2*pairs]
    def writeData(self):
        for line in self.lines:
            self.fileHandle.write(line + "\n")
    def tturnRight(self, num):
        if num == 1:
            self.turnedRight = 1
            ai.turnRight(1)
        else :
            ai.turnRight(0)
            self.turnedRight = 0
    def tturnLeft(self, num):
        if num == 1:
            self.turnedLeft = 1
            ai.turnLeft(1)
        else:
            ai.turnLeft(0)
            self.turnedLeft = 0
    def tthrust(self, num):
        global thrusted
        if num == 1:
            ai.thrust(1)
            self.thrusted = 1
        else:
            ai.thrust(0)
            self.thrusted = 0
    def tshoot(self):
        ai.fireShot()
        self.shot = 1
class DataRecorder:
    def __init__(self):
        self.baseString = "["
    def reset(self):
        self.baseString = "["
    def add(self,  el):
       self.baseString = self.baseString + str(el) + ","
    def getString(self):
        return self.baseString[0:len(self.baseString)-1] + "]"

DataMinerBD = BotData("data.txt")#James Conley - January 2018
import libpyAI as ai
import math
lastTurn = 1
def AI_loop():

    #Inserted Code
    lastLoop = 0
    if ai.selfAlive():
        lastLoop = 1 
        DataMinerBD.updateInputs()
        DataMinerBD.updateOutputs()
        DataMinerBD.savePair()
        print(DataMinerBD.length())
        if DataMinerBD.length() > 10000:
            DataMinerBD.writeData()
            print("Finished")
            ai.quitAI()
    else:
        if lastLoop == 1:
            DataMinerBD.writeDeath()
    global lastTurn
    #Release keys
    DataMinerBD.tthrust(0)
    DataMinerBD.tturnLeft(0)
    DataMinerBD.tturnRight(0)
    ai.setTurnSpeed(45)
    #Set variables"""
    heading = int(ai.selfHeadingDeg())
    tracking = int(ai.selfTrackingDeg())
    trackWall = ai.wallFeeler(500,  tracking)
    trackLWall = ai.wallFeeler(500,  tracking+3)
    trackRWall = ai.wallFeeler(500,  tracking - 3)
    frontWall = ai.wallFeeler(500,heading)
    flWall = ai.wallFeeler(500,  heading + 10)
    frWall = ai.wallFeeler(500,  heading - 10)
    leftWall = ai.wallFeeler(500,heading+90)
    rightWall = ai.wallFeeler(500,heading-90)
    trackWall = ai.wallFeeler(500,tracking)
    backWall = ai.wallFeeler(500, heading - 180)
    backLeftWall = ai.wallFeeler(500,  heading - 185)
    backRightWall = ai.wallFeeler(500,  heading - 175)
    speed = ai.selfSpeed()
   
    closest = min(frontWall, leftWall, rightWall, backWall)
    def closestWall(x): #Find the closest Wall
        return {
            frontWall : 1, 
            leftWall : 2, 
            rightWall : 3, 
            backWall : 4, 
            flWall : 5, 
            frWall : 6, 
        }[x]
    wallNum = closestWall(closest)
    
    #Code for finding the angle to the closest ship
    target = ai.closestShipId()
    targetX,  targetY = ai.screenEnemyX(0), ai.screenEnemyY(0)
    calcDir = 0
    
    if targetX- ai.selfX() != 0:
        calcDir = (math.degrees(math.atan2((targetY - ai.selfY()), (targetX- ai.selfX()))) + 360)%360
    targetDir = calcDir
    crashWall = min(trackWall,  trackLWall,  trackRWall) #The wall we are likely to crash into if we continue on our current course
    #Rules for turning
    if crashWall > 25*speed and closest > 30 and targetX != -1:  #If we are far enough away from a predicted crash and no closer than 25 pixels to a wall, and there isn't a wall between us and the closest enemy
        #print("Aiming",  targetDir,  " Current",  heading)
        diff = (calcDir - heading)
        if ai.shotAlert(0) > -1 and ai.shotAlert(0) < 35:
            DataMinerBD.tturnRight(1)
            DataMinerBD.tthrust(1)
        elif diff >= 0:
            if diff >= 180:
                a = 0
                DataMinerBD.tturnRight(1)     #If the target is to our right- turn right
            elif diff != 0 :              
                a = 0
                
                DataMinerBD.tturnLeft(1)      #If the target is to our left - turn left
        else :
            if diff > -180:
                a = 0
                DataMinerBD.tturnRight(1)     #If the target is to our right - turn right
            else :
                a = 0
                DataMinerBD.tturnLeft(1)      #If the target is to our left - turn left
    else : #Rules for avoiding death
       # if crashWall/ai.selfSpeed() > ai.closestShot() :
       #We find a target heading using our current trajectory and the closest wall then turn in it's direction
        targetHeading = heading
        print(heading)
        if wallNum == 1or wallNum == 6 or wallNum == 5:    #Front Wall is Closest
            if lastTurn == 1:
                targetHeading += 270
                targetHeading = (targetHeading)%360
            else :
                targetHeading +=90
                targetHeading = targetHeading%360
            
            print("front")
        elif wallNum == 2  :  # Left Wall is Closest
            targetHeading += 270
            targetHeading = (targetHeading)%360
            lastTurn = 1
            print("leftwall")
        elif wallNum == 3  :
            targetHeading = targetHeading + 90
            targetHeading = (targetHeading)%360
            lastTurn = 2
            print("rightWall")
        else :
            if backLeftWall < backRightWall:
                lastTurn = 2
                targetHeading += 5
                targetHeading = (targetHeading)%360
            if backLeftWall > backRightWall:
                lastTurn = 1
                targetHeading -= 5
                targetHeading = (targetHeading)%360
       
        speedConcern = ai.selfSpeed() - 4
        
        if speedConcern < 0:
            speedConcern = 0
        elif speedConcern > 5:
            speedConcern = 5
        
        #targetHeading = (targetHeading*(1-(speedConcern/5))) + (((tracking+170)%360)*(speedConcern/5))
        if speedConcern > 2:
            targetHeading = (tracking + 180)%360
        
        diff = (targetHeading - heading)
        print("targetHEading : ", targetHeading,  " heading : ",  heading)
        if diff >= 0:
            if diff >= 180:
                DataMinerBD.tturnRight(1)     #If the targetHEading is to our right- turn right
                
                print("right")
            elif diff != 0 :                       
                DataMinerBD.tturnLeft(1)      #If the targeHeadingt is to our left - turn left
                print("left")
        else :
            if diff > -180:
                print("right")
                DataMinerBD.tturnRight(1)     #If the targetHeading is to our right - turn right
                #print("right")
            else :
                print("left")
                DataMinerBD.tturnLeft(1)      #If the targetHeading is to our left - turn left
            #print("nice")
    
    #Rules for thrusting
    
    if speed < 5 and frontWall > 200:   #If we are moving slowly and we won't ram into anything, accelerate
        DataMinerBD.tthrust(1)
    elif crashWall < 25*speed  and (abs(tracking - heading) > 120):  #If we are getting close to a wall, and we can thrust away from it, do so
        DataMinerBD.tthrust(1)
    elif backWall < 30: #If there is a wall very close behind us, get away from it
        DataMinerBD.tthrust(1)
    
    if abs(calcDir - heading) < 15 : #If we are close to the current proper trajectory for a shot then fire
        DataMinerBD.tshoot()
    
    #"""

ai.start(AI_loop,["-name","smarto","-join","localhost"])    



