from pybrain.tools.customxml.networkreader import NetworkReader
from pybrain.structure.modules import LSTMLayer
from pybrain.structure.modules import SoftmaxLayer
from pybrain.structure.modules import SigmoidLayer
import libpyAI as ai
import math

class controller:
    
    def __init__(self):
        self.steeringNet = NetworkReader.readFrom('LstmSteeringNetwork.xml')
        self.thrustingNet = NetworkReader.readFrom('LstmThrustingNetwork.xml')
        self.shootingNet = NetworkReader.readFrom('LstmShootingNetwork.xml')
        self.steerInputs = []
        self.thrustInputs = []
        self.shootInputs = []
        
        
    def addInput(self,  input):
        self.steerInputs.append(input)
        self.thrustInputs.append(input)
        self.shootInputs.append(input)
    def addTurnInput(self,  data):
        self.steerInputs.append(data)
    def addThrustInput(self,  data):
        self.thrustInputs.append(data)
    def addShootInput(self,  data):
        self.shootInputs.append(data)
    def resetInputs(self):
        self.steerInputs = []
        self.thrustInputs = []
        self.shootInputs = []
    def printInputs(self):
        print(self.steerInputs)
        print(self.thrustInputs)
        print(self.shootInputs)
    def getInputs(self):
        #The code in config is inserted into the updateInputs function so you can pull any data you want using ai.(some xpilot-ai function) and adding it with self.addInput("Some Float")
        #You can technically also add outputs with self.addOutput if you want your neural network to predict or control something beyond normal but this might not work nicely with the autogenerated controller
        #The trainer checks the size of both the input and output datasets and will build a network to accomodate these sizes automatically

        #Until the next comment is code for pulling relevant data from the game
        heading = int(ai.selfHeadingDeg())
        tracking = int(ai.selfTrackingDeg())
        
        backWall = ai.wallFeeler(500, heading - 180)
        backLeftWall = ai.wallFeeler(500,  heading - 190)
        backRightWall = ai.wallFeeler(500,  heading - 170)
        
        frontWall = ai.wallFeeler(500,heading)
        flWall = ai.wallFeeler(500,  heading + 10)
        frWall = ai.wallFeeler(500,  heading - 10)
        
        leftWall = ai.wallFeeler(500,heading+90)
        llWall = ai.wallFeeler(500,  heading + 100)
        rlWall = ai.wallFeeler(500,  heading + 80)
        
        rightWall = ai.wallFeeler(500,heading-90)
        lrWall = ai.wallFeeler(500,  heading - 80)
        rrWall = ai.wallFeeler(500,  heading - 100)
        
        calcDir = -1
        targetX,  targetY = ai.screenEnemyX(0), ai.screenEnemyY(0)
        if targetX- ai.selfX() != 0:
            calcDir = (math.degrees(math.atan2((targetY - ai.selfY()), (targetX- ai.selfX()))) + 360)%360
    
        speed = ai.selfSpeed()
        fFan = min(frontWall,  flWall,  frWall)
        lFan = min(leftWall,  llWall,  rlWall)
        rFan = min(rightWall,  rrWall,  lrWall)
        bFan = min(backWall,  backLeftWall,  backRightWall)
        trackWall = ai.wallFeeler(500, tracking)
        
        #Everything below here is just selecting inputs for training - play around by commenting and uncommenting different inputs, or try adding your own!
        self.addTurnInput(frontWall/500)
        self.addTurnInput(leftWall/500)
        self.addTurnInput(rightWall/500)
        self.addTurnInput(backWall/500)
        self.addTurnInput(trackWall/500)
        #self.addTurnInput(backLeftWall/500)
        #self.addTurnInput(backRightWall/500)


        #self.addInput(fFan)
        #self.addInput(rFan)
        #self.addInput(lFan)
        #self.addInput(bFan)
        #self.addInput(tracking)

        self.addShootInput(heading/360)
        self.addShootInput(calcDir/360)
        
        self.addThrustInput(heading/360) 
        self.addThrustInput(speed/5)
        self.addThrustInput(trackWall/500)
        self.addThrustInput(backWall/500)
        self.addThrustInput(tracking/500)
        



    def act(self):
        if ai.selfAlive():
            self.getInputs()
            #self.printInputs()
            steerOutput = self.steeringNet.activate(self.steerInputs)[0]
            thrustOutput = self.thrustingNet.activate(self.thrustInputs)[0]
            shootOutput = self.shootingNet.activate(self.shootInputs)[0]
            print([steerOutput,  thrustOutput,  shootOutput])
            if steerOutput > .5:
                ai.turnLeft(1)
                ai.turnRight(0)
            else:
                ai.turnRight(1)
                ai.turnLeft(0)
            if thrustOutput > .5:
                ai.thrust(1)
            else :
                ai.thrust(0)
            if shootOutput > .5:
                ai.fireShot()
            self.resetInputs()
        else:
            self.steeringNet.reset()
            self.thrustingNet.reset()
            self.shootingNet.reset()
        
con = controller()
def AI_loop():
    con.act()
ai.start(AI_loop,["-name","Mimic","-join","localhost"])    
