from pybrain.tools.customxml.networkreader import NetworkReader
from pybrain.structure.modules import LSTMLayer
from pybrain.structure.modules import SoftmaxLayer
from pybrain.structure.modules import SigmoidLayer
import libpyAI as ai
import math


import libpyAI as ai
class BotData:
    def __init__(self,  filename):
        self.fileHandle = open(filename,  'w')
        
        self.turnDR = DataRecorder()
        self.thrustDR = DataRecorder()
        self.shootDR = DataRecorder()
        
        #TurnThrustShoot - that is the order
        self.inputDR = DataRecorder()
        self.outputDR = DataRecorder()
        self.lines = []
        self.turnedLeft,  self.turnedRight,  self.thrusted,  self.shot = 0, 0, 0, 0
    def writeDeath(self):
        self.fileHandle.write("DEAD")
    def length(self):
        return len(self.lines)
    def addInput(self,  data):
        self.turnDR.add(data)
        self.thrustDR.add(data)
        self.shootDR.add(data)
    def addTurnInput(self,  data):
        self.turnDR.add(data)
    def addThrustInput(self,  data):
        self.thrustDR.add(data)
    def addShootInput(self,  data):
        self.shootDR.add(data)
    def updateInputs(self):
        
        #The code in config is inserted into the updateInputs function so you can pull any data you want using ai.(some xpilot-ai function) and adding it with self.addInput("Some Float")
        #You can technically also add outputs with self.addOutput if you want your neural network to predict or control something beyond normal but this might not work nicely with the autogenerated controller
        #The trainer checks the size of both the input and output datasets and will build a network to accomodate these sizes automatically

        #Until the next comment is code for pulling relevant data from the game
        heading = int(ai.selfHeadingDeg())
        tracking = int(ai.selfTrackingDeg())
        
        backWall = ai.wallFeeler(500, heading - 180)
        backLeftWall = ai.wallFeeler(500,  heading - 190)
        backRightWall = ai.wallFeeler(500,  heading - 170)
        
        frontWall = ai.wallFeeler(500,heading)
        flWall = ai.wallFeeler(500,  heading + 10)
        frWall = ai.wallFeeler(500,  heading - 10)
        
        leftWall = ai.wallFeeler(500,heading+90)
        llWall = ai.wallFeeler(500,  heading + 100)
        rlWall = ai.wallFeeler(500,  heading + 80)
        
        rightWall = ai.wallFeeler(500,heading-90)
        lrWall = ai.wallFeeler(500,  heading - 80)
        rrWall = ai.wallFeeler(500,  heading - 100)
        
        

        calcDir = 0
        targetX,  targetY = ai.screenEnemyX(0), ai.screenEnemyY(0)
        if targetX- ai.selfX() != 0:
            calcDir = int(math.degrees(math.atan2((targetY - ai.selfY()), (targetX- ai.selfX()))) + 360)%360
    
        calcDiff = ai.angleDiff(heading, calcDir)
        trackDiff = ai.angleDiff(heading, tracking)



        speed = ai.selfSpeed()
        fFan = min(frontWall,  flWall,  frWall)
        lFan = min(leftWall,  llWall,  rlWall)
        rFan = min(rightWall,  rrWall,  lrWall)
        bFan = min(backWall,  backLeftWall,  backRightWall)
        trackWall = ai.wallFeeler(500, tracking)
        
        #Everything below here is just selecting inputs for training - play around by commenting and uncommenting different inputs, or try adding your own!
        self.addTurnInput(1/(frontWall+1))
        self.addTurnInput(1/(leftWall+1))
        self.addTurnInput(1/(rightWall+1))
        self.addTurnInput(1/(backWall+1))
        self.addTurnInput(calcDiff/180)
        self.addTurnInput(trackDiff/180)
        self.addTurnInput(speed/(trackWall+1))
        #self.addTurnInput(heading/360)
        #self.addTurnInput(calcDir/360)
        
        #self.addTurnInput(1/(backLeftWall+1))
        #self.addTurnInput(1/(backRightWall+1))
        

        #self.addInput(fFan)
        #self.addInput(rFan)
        #self.addInput(lFan)
        #self.addInput(bFan)
        #self.addInput(tracking)

        self.addShootInput(calcDiff/180)
        
        self.addThrustInput(trackDiff/180)
        self.addThrustInput(speed)
        self.addThrustInput(1/(trackWall+1))
        self.addThrustInput(1/(backWall+1))
        


        
    def addOutput(self,  data):
        self.outputDR.add(data)
    def updateOutputs(self):
        self.addOutput(self.turnedLeft)
        self.addOutput(self.turnedRight)
        self.addOutput(self.thrusted)
        self.addOutput(self.shot)
        self.shot = 0
        
    def reset(self):
        self.inputDR.reset()
        self.outputDR.reset()
        
    def resetInput(self):
        self.inputDR.reset()
    def savePair(self):
        self.inputDR.add(self.turnDR.getString())
        self.inputDR.add(self.thrustDR.getString())
        self.inputDR.add(self.shootDR.getString())
        
        self.lines.append(self.inputDR.getString())
        self.lines.append(self.outputDR.getString())
        
        self.turnDR.reset()
        self.thrustDR.reset()
        self.shootDR.reset()
        self.inputDR.reset()
        self.outputDR.reset()
        self.outputDR.reset()
    def deleteData(self,  pairs):
        self.lines = self.lines[0:-2*pairs]
    def writeData(self):
        for line in self.lines:
            self.fileHandle.write(line + "\n")
    def tturnRight(self, num):
        if num == 1:
            self.turnedRight = 1
            ai.turnRight(1)
        else :
            ai.turnRight(0)
            self.turnedRight = 0
    def tturnRightDummy(self, num):
        if num == 1:
            self.turnedRight = 1
            #ai.turnRight(1)
        else :
            #ai.turnRight(0)
            self.turnedRight = 0
    def tturnLeft(self, num):
        if num == 1:
            self.turnedLeft = 1
            ai.turnLeft(1)
        else:
            ai.turnLeft(0)
            self.turnedLeft = 0
    def tturnLeftDummy(self, num):
        if num == 1:
            self.turnedLeft = 1
            #ai.turnLeft(1)
        else:
            #ai.turnLeft(0)
            self.turnedLeft = 0
    def tthrust(self, num):
        global thrusted
        if num == 1:
            ai.thrust(1)
            self.thrusted = 1
        else:
            ai.thrust(0)
            self.thrusted = 0
    def tthrustDummy(self, num):
        global thrusted
        if num == 1:
            #ai.thrust(1)
            self.thrusted = 1
        else:
            #ai.thrust(0)
            self.thrusted = 0
    def tshoot(self):
        ai.fireShot()
        self.shot = 1
    def tshootDummy(self):
        #ai.fireShot()
        self.shot = 1
class DataRecorder:
    def __init__(self):
        self.baseString = "["
    def reset(self):
        self.baseString = "["
    def add(self,  el):
       self.baseString = self.baseString + str(el) + ","
    def getString(self):
        return self.baseString[0:len(self.baseString)-1] + "]"

DataMinerBD = BotData("data.txt")

class controller:
    
    def __init__(self):
        self.steeringNet = NetworkReader.readFrom('LstmSteeringNetwork.xml')
        self.thrustingNet = NetworkReader.readFrom('LstmThrustingNetwork.xml')
        self.shootingNet = NetworkReader.readFrom('LstmShootingNetwork.xml')
        self.steerInputs = []
        self.thrustInputs = []
        self.shootInputs = []
        
        
    def addInput(self,  input):
        self.steerInputs.append(input)
        self.thrustInputs.append(input)
        self.shootInputs.append(input)
    def addTurnInput(self,  data):
        self.steerInputs.append(data)
    def addThrustInput(self,  data):
        self.thrustInputs.append(data)
    def addShootInput(self,  data):
        self.shootInputs.append(data)
    def resetInputs(self):
        self.steerInputs = []
        self.thrustInputs = []
        self.shootInputs = []
    def printInputs(self):
        print(self.steerInputs)
        print(self.thrustInputs)
        print(self.shootInputs)
    def dummyCode(self):
#James Conley - January 2018
          import libpyAI as ai
          import math
          
          
          
          
          global maxSpeed,  shotAngle,  wallClose
          maxSpeed = 5
          shotAngle = 9
          wallClose = 15
          
          
          
          
          
          
          previousScore = 0
          def dummyLoop():
              global maxSpeed,  shotAngle,  wallClose,  dead,  previousScore
              global turnedLeft,  turnedRight,  thrusted,  shot
              
              
              #Release keys
              DataMinerBD.tthrustDummy(0)
              DataMinerBD.tturnLeftDummy(0)
              DataMinerBD.tturnRightDummy(0)
              ai.setTurnSpeed(45)
              #Set variables"""
              heading = int(ai.selfHeadingDeg())
              tracking = int(ai.selfTrackingDeg())
              
              trackWall = ai.wallFeeler(500,  tracking)
              trackLWall = ai.wallFeeler(500,  tracking+3)
              trackRWall = ai.wallFeeler(500,  tracking - 3)
             
              frontWall = ai.wallFeeler(500,heading)
              flWall = ai.wallFeeler(500,  heading + 10)
              frWall = ai.wallFeeler(500,  heading - 10)
              
              leftWall = ai.wallFeeler(500,heading+90)
              llWall = ai.wallFeeler(500,  heading + 100)
              rlWall = ai.wallFeeler(500,  heading + 80)
              
              rightWall = ai.wallFeeler(500,heading-90)
              lrWall = ai.wallFeeler(500,  heading - 80)
              rrWall = ai.wallFeeler(500,  heading - 100)
              
              trackWall = ai.wallFeeler(500,tracking)
              backWall = ai.wallFeeler(500, heading - 180)
              backLeftWall = ai.wallFeeler(500,  heading - 190)
              backRightWall = ai.wallFeeler(500,  heading - 170)
              speed = ai.selfSpeed()
              
             
              
              closest = min(frontWall, leftWall, rightWall, backWall,  flWall,  frWall)
              def closestWall(x): #Find the closest Wall
                  return {
                      frontWall : 1, 
                      leftWall : 2, 
                      rightWall : 3, 
                      backWall : 4, 
                      flWall : 5, 
                      frWall : 6, 
                  }[x]
              wallNum = closestWall(closest)
              
              #Code for finding the angle to the closest ship
              targetX,  targetY = ai.screenEnemyX(0), ai.screenEnemyY(0)
             
             
              #baseString = "["+str(flWall/500)+","+str(frontWall/500)+","+str(frWall/500) + "," + str(backLeftWall/500) + "," + str(backWall/500) + "," + str(backRightWall/500) + ","+str(leftWall/500)+","+str(rightWall/500)+","+str(trackLWall/500) + "," + str(trackWall/500) + ","+str(trackRWall/500) + "," + str(speed/10)
              
              calcDir = -1
              if targetX- ai.selfX() != 0:
                  calcDir = (math.degrees(math.atan2((targetY - ai.selfY()), (targetX- ai.selfX()))) + 360)%360
              crashWall = min(trackWall,  trackLWall,  trackRWall) #The wall we are likely to crash into if we continue on our current course
              #Rules for turning
              if crashWall > wallClose*speed and closest > 25 and targetX != -1:  #If we are far enough away from a predicted crash and no closer than 25 pixels to a wall we can try and aim and kill them
                  diff = (calcDir - heading)
                  #if ai.shotAlert(0) > -1 and ai.shotAlert(0) < 35:   #If we are about to get shot
                  #    tturnRight(1)                                                     #Screw aiming and turn right and thrust
                  #    tthrust(1)                                                            #This is arguably a horrible strategy because our sideways profile is much larger, but it's required for the grade
                  if diff >= 0:
                      if diff >= 180:
                          DataMinerBD.tturnRightDummy(1)     #If the target is to our right- turn right
                         
                      else :                       
                          DataMinerBD.tturnLeftDummy(1)      #If the target is to our left - turn left
                          
                  else :
                      if diff > -180:
                          DataMinerBD.tturnRightDummy(1)     #If the target is to our right - turn right
                         
                      else :
                          DataMinerBD.tturnLeftDummy(1)      #If the target is to our left - turn left
                       
              else : #Rules for avoiding death
                 # if crashWall/ai.selfSpeed() > ai.closestShot() :
                  if wallNum == 1 or wallNum == 5 or wallNum == 6:    #Front Wall is Closest (Turn Away From It)
                      DataMinerBD.tturnLeftDummy(1)
                     
                  elif wallNum == 2 :  # Left Wall is Closest (Turn Away From It)
                      DataMinerBD.tturnRightDummy(1)
                      
                  elif wallNum == 3 :   #Right Wall is Closest (Turn Away From It)
                      DataMinerBD.tturnLeftDummy(1)
                     
                  else :                                                      #Back Wall is closest- turn so that we are facing directly away from it
                      if backLeftWall < backRightWall:
                         DataMinerBD.tturnRightDummy(1)                                  #We need to turn right to face more directly away from it
                        
                        
                      if backLeftWall > backRightWall:        # We need to turn left to face more directly away from it
                         DataMinerBD.tturnLeftDummy(1)
                        
                 
                 
              
              #Rules for thrusting
              
              if speed < maxSpeed and frontWall > 100:   #If we are moving slowly and we won't ram into anything, accelerate
                  DataMinerBD.tthrustDummy(1)
              elif trackWall < 200  and (ai.angleDiff(heading,  tracking) > 120):  #If we are getting close to a wall, and we can thrust away from it, do so
                  DataMinerBD.tthrustDummy(1)
              elif backWall < 20: #If there is a wall very close behind us, get away from it
                  DataMinerBD.tthrustDummy(1)
              
              if abs(calcDir - heading) < shotAngle and calcDir != -1: #If we are close to the current proper trajectory for a shot then fire
                  DataMinerBD.tshootDummy()
             
              previousScore = ai.selfScore()
             
          
          dummyLoop()


    def getInputs(self):
        #The code in config is inserted into the updateInputs function so you can pull any data you want using ai.(some xpilot-ai function) and adding it with self.addInput("Some Float")
        #You can technically also add outputs with self.addOutput if you want your neural network to predict or control something beyond normal but this might not work nicely with the autogenerated controller
        #The trainer checks the size of both the input and output datasets and will build a network to accomodate these sizes automatically

        #Until the next comment is code for pulling relevant data from the game
        heading = int(ai.selfHeadingDeg())
        tracking = int(ai.selfTrackingDeg())
        
        backWall = ai.wallFeeler(500, heading - 180)
        backLeftWall = ai.wallFeeler(500,  heading - 190)
        backRightWall = ai.wallFeeler(500,  heading - 170)
        
        frontWall = ai.wallFeeler(500,heading)
        flWall = ai.wallFeeler(500,  heading + 10)
        frWall = ai.wallFeeler(500,  heading - 10)
        
        leftWall = ai.wallFeeler(500,heading+90)
        llWall = ai.wallFeeler(500,  heading + 100)
        rlWall = ai.wallFeeler(500,  heading + 80)
        
        rightWall = ai.wallFeeler(500,heading-90)
        lrWall = ai.wallFeeler(500,  heading - 80)
        rrWall = ai.wallFeeler(500,  heading - 100)
        
        

        calcDir = 0
        targetX,  targetY = ai.screenEnemyX(0), ai.screenEnemyY(0)
        if targetX- ai.selfX() != 0:
            calcDir = int(math.degrees(math.atan2((targetY - ai.selfY()), (targetX- ai.selfX()))) + 360)%360
    
        calcDiff = ai.angleDiff(heading, calcDir)
        trackDiff = ai.angleDiff(heading, tracking)



        speed = ai.selfSpeed()
        fFan = min(frontWall,  flWall,  frWall)
        lFan = min(leftWall,  llWall,  rlWall)
        rFan = min(rightWall,  rrWall,  lrWall)
        bFan = min(backWall,  backLeftWall,  backRightWall)
        trackWall = ai.wallFeeler(500, tracking)
        
        #Everything below here is just selecting inputs for training - play around by commenting and uncommenting different inputs, or try adding your own!
        self.addTurnInput(1/(frontWall+1))
        self.addTurnInput(1/(leftWall+1))
        self.addTurnInput(1/(rightWall+1))
        self.addTurnInput(1/(backWall+1))
        self.addTurnInput(calcDiff/180)
        self.addTurnInput(trackDiff/180)
        self.addTurnInput(speed/(trackWall+1))
        #self.addTurnInput(heading/360)
        #self.addTurnInput(calcDir/360)
        
        #self.addTurnInput(1/(backLeftWall+1))
        #self.addTurnInput(1/(backRightWall+1))
        

        #self.addInput(fFan)
        #self.addInput(rFan)
        #self.addInput(lFan)
        #self.addInput(bFan)
        #self.addInput(tracking)

        self.addShootInput(calcDiff/180)
        
        self.addThrustInput(trackDiff/180)
        self.addThrustInput(speed)
        self.addThrustInput(1/(trackWall+1))
        self.addThrustInput(1/(backWall+1))
        



    def act(self):
        if ai.selfAlive():
            self.getInputs()
            #self.printInputs()
            steerOutput = self.steeringNet.activate(self.steerInputs)[0]
            thrustOutput = self.thrustingNet.activate(self.thrustInputs)[0]
            shootOutput = self.shootingNet.activate(self.shootInputs)[0]
            print([steerOutput,  thrustOutput,  shootOutput])
            if steerOutput > .5:
                ai.turnLeft(1)
                ai.turnRight(0)
            else:
                ai.turnRight(1)
                ai.turnLeft(0)
            if thrustOutput > .5:
                ai.thrust(1)
            else :
                ai.thrust(0)
            if shootOutput > .5:
                ai.fireShot()
            self.resetInputs()
        else:
            self.steeringNet.reset()
            self.thrustingNet.reset()
            self.shootingNet.reset()
        
con = controller()
global loopCount,  lastLoop
loopCount = 0
lastLoop = 0
def AI_loop():
    
    if ai.selfAlive():
        
        global loopCount,  lastLoop
        con.act()
        loopCount+=1
        con.dummyCode()
        DataMinerBD.updateInputs()
        DataMinerBD.updateOutputs()
        DataMinerBD.savePair()
        if loopCount % 100 == 0:
            print(loopCount)
        if loopCount > 1000:
            DataMinerBD.writeData()
            ai.quitAI()
        lastLoop = 1
    else:
        if lastLoop == 1:
            DataMinerBD.writeDeath()
    lastLoop = 0
ai.start(AI_loop,["-name","Mimic","-join","localhost"])    
